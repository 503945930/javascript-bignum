TODO:

* Fix (expt 0 0) in maint branches as per the example in R6RS.

* Backport fix: (angle 1.0) must be inexact.

* Decimal: Test and debug.

* Leemon Baird BigInt wrapper: optimize.  Add exactIntegerSqrt.

* Provide a choice among different implementations of complex numbers
  and inexact reals.

* Support primitive numbers as exact values using conditionals,
  typeof, and lifting as in js-numbers.

* This returns 5 (correctly) on FF but 3 on Chrome:
    var ret = gmp.mpq();
    gmp.mpq_set_str(ret,"2/3",0);
    var nr = gmp.mpq_numref(ret);
    gmp.mpz_add(nr,nr,gmp.mpq_denref(ret));
    return nr.toString();

* Create integer and rational implementations using the GMP plug-in.
  Interface design ideas: Flusspferd (http://flusspferd.github.com/)
  GMP module, node-gmp (https://github.com/postwait/node-gmp),
  node-bigint (https://github.com/substack/node-bigint).

* On GMP, consider hybrid implementations with runtime optimal
  threshold discovery, since the plugin may or may not be in-process,
  and in-process calls can be over 100x faster than out-of-process.

* Consider avoidance or mitigation of GMP calls to abort() and
  division-by-zero.

* Add MPFR functions to the GMP plugin.  Create a high-precision
  inexact number implementation on MPFR.

* FF in-process crash on exit, perhaps printing "out of memory":
    var a=[]; for (var i in lib) {a.push(i)} alert(a);
  Also crash on exit after running the mpq_numref example above.

* Consider adding GMP bindings for randstate and mpf_t.

* Reimplement the performance benefit of using Number.prototype for
  inexact, but make it optional.

* Implement (rnrs arithmetic bitwise) functions.

* Think about what to do with "#e1@1".

* Consider supporting a configuration where inexact reals are returned
  as primitive numbers but Number.prototype is not used.

* Consider supporting primitive numbers as exact values using
  Number.prototype.

* Avoid "x in y" out of concern for Object.prototype use.

* Consider supporting continuation-passing style for the benefit of
  Scheme(?) and PPAPI.

* Consider merging the plugin architecture into D. Yoo's js-numbers.

* Consider type implementations that dynamically measure usage and
  change representations on-the-fly to improve performance (run-time
  optimization).
